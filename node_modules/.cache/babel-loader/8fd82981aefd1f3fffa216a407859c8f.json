{"ast":null,"code":"import _classCallCheck from \"/Users/ayubmohamed/emwb/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/ayubmohamed/emwb/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport debounce from 'lodash/debounce';\nimport { scrollable, dataPolarisTopBar } from '../../components/shared.js';\nimport { stackedContent } from '../breakpoints.js';\nimport { getRectForNode } from '../geometry.js';\nimport { tokens } from '../../tokens/tokens.js';\nvar SIXTY_FPS = 1000 / 60;\n\nvar StickyManager = /*#__PURE__*/function () {\n  function StickyManager(container) {\n    var _this = this;\n\n    _classCallCheck(this, StickyManager);\n\n    this.stickyItems = [];\n    this.stuckItems = [];\n    this.container = null;\n    this.topBarOffset = 0;\n    this.handleResize = debounce(function () {\n      _this.manageStickyItems();\n    }, SIXTY_FPS, {\n      leading: true,\n      trailing: true,\n      maxWait: SIXTY_FPS\n    });\n    this.handleScroll = debounce(function () {\n      _this.manageStickyItems();\n    }, SIXTY_FPS, {\n      leading: true,\n      trailing: true,\n      maxWait: SIXTY_FPS\n    });\n\n    if (container) {\n      this.setContainer(container);\n    }\n  }\n\n  _createClass(StickyManager, [{\n    key: \"registerStickyItem\",\n    value: function registerStickyItem(stickyItem) {\n      this.stickyItems.push(stickyItem);\n    }\n  }, {\n    key: \"unregisterStickyItem\",\n    value: function unregisterStickyItem(nodeToRemove) {\n      var nodeIndex = this.stickyItems.findIndex(function (_ref) {\n        var stickyNode = _ref.stickyNode;\n        return nodeToRemove === stickyNode;\n      });\n      this.stickyItems.splice(nodeIndex, 1);\n    }\n  }, {\n    key: \"setContainer\",\n    value: function setContainer(el) {\n      this.container = el;\n\n      if (isDocument(el)) {\n        this.setTopBarOffset(el);\n      }\n\n      this.container.addEventListener('scroll', this.handleScroll);\n      window.addEventListener('resize', this.handleResize);\n      this.manageStickyItems();\n    }\n  }, {\n    key: \"removeScrollListener\",\n    value: function removeScrollListener() {\n      if (this.container) {\n        this.container.removeEventListener('scroll', this.handleScroll);\n        window.removeEventListener('resize', this.handleResize);\n      }\n    }\n  }, {\n    key: \"manageStickyItems\",\n    value: function manageStickyItems() {\n      var _this2 = this;\n\n      if (this.stickyItems.length <= 0) {\n        return;\n      }\n\n      var scrollTop = this.container ? scrollTopFor(this.container) : 0;\n      var containerTop = getRectForNode(this.container).top + this.topBarOffset;\n      this.stickyItems.forEach(function (stickyItem) {\n        var handlePositioning = stickyItem.handlePositioning;\n\n        var _this2$evaluateSticky = _this2.evaluateStickyItem(stickyItem, scrollTop, containerTop),\n            sticky = _this2$evaluateSticky.sticky,\n            top = _this2$evaluateSticky.top,\n            left = _this2$evaluateSticky.left,\n            width = _this2$evaluateSticky.width;\n\n        _this2.updateStuckItems(stickyItem, sticky);\n\n        handlePositioning(sticky, top, left, width);\n      });\n    }\n  }, {\n    key: \"evaluateStickyItem\",\n    value: function evaluateStickyItem(stickyItem, scrollTop, containerTop) {\n      var stickyNode = stickyItem.stickyNode,\n          placeHolderNode = stickyItem.placeHolderNode,\n          boundingElement = stickyItem.boundingElement,\n          offset = stickyItem.offset,\n          disableWhenStacked = stickyItem.disableWhenStacked;\n\n      if (disableWhenStacked && stackedContent().matches) {\n        return {\n          sticky: false,\n          top: 0,\n          left: 0,\n          width: 'auto'\n        };\n      }\n\n      var stickyOffset = offset ? this.getOffset(stickyNode) + parseInt(tokens.spacing['5'], 10) : this.getOffset(stickyNode);\n      var scrollPosition = scrollTop + stickyOffset;\n      var placeHolderNodeCurrentTop = placeHolderNode.getBoundingClientRect().top - containerTop + scrollTop;\n      var top = containerTop + stickyOffset;\n      var width = placeHolderNode.getBoundingClientRect().width;\n      var left = placeHolderNode.getBoundingClientRect().left;\n      var sticky;\n\n      if (boundingElement == null) {\n        sticky = scrollPosition >= placeHolderNodeCurrentTop;\n      } else {\n        var _stickyNode$firstElem;\n\n        var stickyItemHeight = stickyNode.getBoundingClientRect().height || ((_stickyNode$firstElem = stickyNode.firstElementChild) === null || _stickyNode$firstElem === void 0 ? void 0 : _stickyNode$firstElem.getBoundingClientRect().height) || 0;\n        var stickyItemBottomPosition = boundingElement.getBoundingClientRect().bottom - stickyItemHeight + scrollTop - containerTop;\n        sticky = scrollPosition >= placeHolderNodeCurrentTop && scrollPosition < stickyItemBottomPosition;\n      }\n\n      return {\n        sticky: sticky,\n        top: top,\n        left: left,\n        width: width\n      };\n    }\n  }, {\n    key: \"updateStuckItems\",\n    value: function updateStuckItems(item, sticky) {\n      var stickyNode = item.stickyNode;\n\n      if (sticky && !this.isNodeStuck(stickyNode)) {\n        this.addStuckItem(item);\n      } else if (!sticky && this.isNodeStuck(stickyNode)) {\n        this.removeStuckItem(item);\n      }\n    }\n  }, {\n    key: \"addStuckItem\",\n    value: function addStuckItem(stickyItem) {\n      this.stuckItems.push(stickyItem);\n    }\n  }, {\n    key: \"removeStuckItem\",\n    value: function removeStuckItem(stickyItem) {\n      var nodeToRemove = stickyItem.stickyNode;\n      var nodeIndex = this.stuckItems.findIndex(function (_ref2) {\n        var stickyNode = _ref2.stickyNode;\n        return nodeToRemove === stickyNode;\n      });\n      this.stuckItems.splice(nodeIndex, 1);\n    }\n  }, {\n    key: \"getOffset\",\n    value: function getOffset(node) {\n      if (this.stuckItems.length === 0) {\n        return 0;\n      }\n\n      var offset = 0;\n      var count = 0;\n      var stuckNodesLength = this.stuckItems.length;\n      var nodeRect = getRectForNode(node);\n\n      while (count < stuckNodesLength) {\n        var stuckNode = this.stuckItems[count].stickyNode;\n\n        if (stuckNode !== node) {\n          var stuckNodeRect = getRectForNode(stuckNode);\n\n          if (!horizontallyOverlaps(nodeRect, stuckNodeRect)) {\n            offset += getRectForNode(stuckNode).height;\n          }\n        } else {\n          break;\n        }\n\n        count++;\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"isNodeStuck\",\n    value: function isNodeStuck(node) {\n      var nodeFound = this.stuckItems.findIndex(function (_ref3) {\n        var stickyNode = _ref3.stickyNode;\n        return node === stickyNode;\n      });\n      return nodeFound >= 0;\n    }\n  }, {\n    key: \"setTopBarOffset\",\n    value: function setTopBarOffset(container) {\n      var topbarElement = container.querySelector(\":not(\".concat(scrollable.selector, \") \").concat(dataPolarisTopBar.selector));\n      this.topBarOffset = topbarElement ? topbarElement.clientHeight : 0;\n    }\n  }]);\n\n  return StickyManager;\n}();\n\nfunction isDocument(node) {\n  return node === document;\n}\n\nfunction scrollTopFor(container) {\n  return isDocument(container) ? document.body.scrollTop || document.documentElement.scrollTop : container.scrollTop;\n}\n\nfunction horizontallyOverlaps(rect1, rect2) {\n  var rect1Left = rect1.left;\n  var rect1Right = rect1.left + rect1.width;\n  var rect2Left = rect2.left;\n  var rect2Right = rect2.left + rect2.width;\n  return rect2Right < rect1Left || rect1Right < rect2Left;\n}\n\nexport { StickyManager };","map":{"version":3,"sources":["/Users/ayubmohamed/emwb/node_modules/@shopify/polaris/build/esm/utilities/sticky-manager/sticky-manager.js"],"names":["debounce","scrollable","dataPolarisTopBar","stackedContent","getRectForNode","tokens","SIXTY_FPS","StickyManager","container","stickyItems","stuckItems","topBarOffset","handleResize","manageStickyItems","leading","trailing","maxWait","handleScroll","setContainer","stickyItem","push","nodeToRemove","nodeIndex","findIndex","stickyNode","splice","el","isDocument","setTopBarOffset","addEventListener","window","removeEventListener","length","scrollTop","scrollTopFor","containerTop","top","forEach","handlePositioning","evaluateStickyItem","sticky","left","width","updateStuckItems","placeHolderNode","boundingElement","offset","disableWhenStacked","matches","stickyOffset","getOffset","parseInt","spacing","scrollPosition","placeHolderNodeCurrentTop","getBoundingClientRect","_stickyNode$firstElem","stickyItemHeight","height","firstElementChild","stickyItemBottomPosition","bottom","item","isNodeStuck","addStuckItem","removeStuckItem","node","count","stuckNodesLength","nodeRect","stuckNode","stuckNodeRect","horizontallyOverlaps","nodeFound","topbarElement","querySelector","selector","clientHeight","document","body","documentElement","rect1","rect2","rect1Left","rect1Right","rect2Left","rect2Right"],"mappings":"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","sourcesContent":["import debounce from 'lodash/debounce';\nimport { scrollable, dataPolarisTopBar } from '../../components/shared.js';\nimport { stackedContent } from '../breakpoints.js';\nimport { getRectForNode } from '../geometry.js';\nimport { tokens } from '../../tokens/tokens.js';\n\nconst SIXTY_FPS = 1000 / 60;\nclass StickyManager {\n  constructor(container) {\n    this.stickyItems = [];\n    this.stuckItems = [];\n    this.container = null;\n    this.topBarOffset = 0;\n    this.handleResize = debounce(() => {\n      this.manageStickyItems();\n    }, SIXTY_FPS, {\n      leading: true,\n      trailing: true,\n      maxWait: SIXTY_FPS\n    });\n    this.handleScroll = debounce(() => {\n      this.manageStickyItems();\n    }, SIXTY_FPS, {\n      leading: true,\n      trailing: true,\n      maxWait: SIXTY_FPS\n    });\n\n    if (container) {\n      this.setContainer(container);\n    }\n  }\n\n  registerStickyItem(stickyItem) {\n    this.stickyItems.push(stickyItem);\n  }\n\n  unregisterStickyItem(nodeToRemove) {\n    const nodeIndex = this.stickyItems.findIndex(({\n      stickyNode\n    }) => nodeToRemove === stickyNode);\n    this.stickyItems.splice(nodeIndex, 1);\n  }\n\n  setContainer(el) {\n    this.container = el;\n\n    if (isDocument(el)) {\n      this.setTopBarOffset(el);\n    }\n\n    this.container.addEventListener('scroll', this.handleScroll);\n    window.addEventListener('resize', this.handleResize);\n    this.manageStickyItems();\n  }\n\n  removeScrollListener() {\n    if (this.container) {\n      this.container.removeEventListener('scroll', this.handleScroll);\n      window.removeEventListener('resize', this.handleResize);\n    }\n  }\n\n  manageStickyItems() {\n    if (this.stickyItems.length <= 0) {\n      return;\n    }\n\n    const scrollTop = this.container ? scrollTopFor(this.container) : 0;\n    const containerTop = getRectForNode(this.container).top + this.topBarOffset;\n    this.stickyItems.forEach(stickyItem => {\n      const {\n        handlePositioning\n      } = stickyItem;\n      const {\n        sticky,\n        top,\n        left,\n        width\n      } = this.evaluateStickyItem(stickyItem, scrollTop, containerTop);\n      this.updateStuckItems(stickyItem, sticky);\n      handlePositioning(sticky, top, left, width);\n    });\n  }\n\n  evaluateStickyItem(stickyItem, scrollTop, containerTop) {\n    const {\n      stickyNode,\n      placeHolderNode,\n      boundingElement,\n      offset,\n      disableWhenStacked\n    } = stickyItem;\n\n    if (disableWhenStacked && stackedContent().matches) {\n      return {\n        sticky: false,\n        top: 0,\n        left: 0,\n        width: 'auto'\n      };\n    }\n\n    const stickyOffset = offset ? this.getOffset(stickyNode) + parseInt(tokens.spacing['5'], 10) : this.getOffset(stickyNode);\n    const scrollPosition = scrollTop + stickyOffset;\n    const placeHolderNodeCurrentTop = placeHolderNode.getBoundingClientRect().top - containerTop + scrollTop;\n    const top = containerTop + stickyOffset;\n    const width = placeHolderNode.getBoundingClientRect().width;\n    const left = placeHolderNode.getBoundingClientRect().left;\n    let sticky;\n\n    if (boundingElement == null) {\n      sticky = scrollPosition >= placeHolderNodeCurrentTop;\n    } else {\n      var _stickyNode$firstElem;\n\n      const stickyItemHeight = stickyNode.getBoundingClientRect().height || ((_stickyNode$firstElem = stickyNode.firstElementChild) === null || _stickyNode$firstElem === void 0 ? void 0 : _stickyNode$firstElem.getBoundingClientRect().height) || 0;\n      const stickyItemBottomPosition = boundingElement.getBoundingClientRect().bottom - stickyItemHeight + scrollTop - containerTop;\n      sticky = scrollPosition >= placeHolderNodeCurrentTop && scrollPosition < stickyItemBottomPosition;\n    }\n\n    return {\n      sticky,\n      top,\n      left,\n      width\n    };\n  }\n\n  updateStuckItems(item, sticky) {\n    const {\n      stickyNode\n    } = item;\n\n    if (sticky && !this.isNodeStuck(stickyNode)) {\n      this.addStuckItem(item);\n    } else if (!sticky && this.isNodeStuck(stickyNode)) {\n      this.removeStuckItem(item);\n    }\n  }\n\n  addStuckItem(stickyItem) {\n    this.stuckItems.push(stickyItem);\n  }\n\n  removeStuckItem(stickyItem) {\n    const {\n      stickyNode: nodeToRemove\n    } = stickyItem;\n    const nodeIndex = this.stuckItems.findIndex(({\n      stickyNode\n    }) => nodeToRemove === stickyNode);\n    this.stuckItems.splice(nodeIndex, 1);\n  }\n\n  getOffset(node) {\n    if (this.stuckItems.length === 0) {\n      return 0;\n    }\n\n    let offset = 0;\n    let count = 0;\n    const stuckNodesLength = this.stuckItems.length;\n    const nodeRect = getRectForNode(node);\n\n    while (count < stuckNodesLength) {\n      const stuckNode = this.stuckItems[count].stickyNode;\n\n      if (stuckNode !== node) {\n        const stuckNodeRect = getRectForNode(stuckNode);\n\n        if (!horizontallyOverlaps(nodeRect, stuckNodeRect)) {\n          offset += getRectForNode(stuckNode).height;\n        }\n      } else {\n        break;\n      }\n\n      count++;\n    }\n\n    return offset;\n  }\n\n  isNodeStuck(node) {\n    const nodeFound = this.stuckItems.findIndex(({\n      stickyNode\n    }) => node === stickyNode);\n    return nodeFound >= 0;\n  }\n\n  setTopBarOffset(container) {\n    const topbarElement = container.querySelector(`:not(${scrollable.selector}) ${dataPolarisTopBar.selector}`);\n    this.topBarOffset = topbarElement ? topbarElement.clientHeight : 0;\n  }\n\n}\n\nfunction isDocument(node) {\n  return node === document;\n}\n\nfunction scrollTopFor(container) {\n  return isDocument(container) ? document.body.scrollTop || document.documentElement.scrollTop : container.scrollTop;\n}\n\nfunction horizontallyOverlaps(rect1, rect2) {\n  const rect1Left = rect1.left;\n  const rect1Right = rect1.left + rect1.width;\n  const rect2Left = rect2.left;\n  const rect2Right = rect2.left + rect2.width;\n  return rect2Right < rect1Left || rect1Right < rect2Left;\n}\n\nexport { StickyManager };\n"]},"metadata":{},"sourceType":"module"}