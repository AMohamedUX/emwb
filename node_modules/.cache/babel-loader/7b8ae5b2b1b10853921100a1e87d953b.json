{"ast":null,"code":"import _toConsumableArray from \"/Users/ayubmohamed/emwb/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/ayubmohamed/emwb/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/ayubmohamed/emwb/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { get } from '../get.js';\nimport { merge } from '../merge.js';\nvar REPLACE_REGEX = /{([^}]*)}/g;\n\nvar I18n = /*#__PURE__*/function () {\n  /**\n   * @param translation A locale object or array of locale objects that overrides default translations. If specifying an array then your desired language dictionary should come first, followed by your fallback language dictionaries\n   */\n  function I18n(translation) {\n    _classCallCheck(this, I18n);\n\n    this.translation = {}; // slice the array to make a shallow copy of it, so we don't accidentally\n    // modify the original translation array\n\n    this.translation = Array.isArray(translation) ? merge.apply(void 0, _toConsumableArray(translation.slice().reverse())) : translation;\n  }\n\n  _createClass(I18n, [{\n    key: \"translate\",\n    value: function translate(id, replacements) {\n      var text = get(this.translation, id, '');\n\n      if (!text) {\n        return '';\n      }\n\n      if (replacements) {\n        return text.replace(REPLACE_REGEX, function (match) {\n          var replacement = match.substring(1, match.length - 1);\n\n          if (replacements[replacement] === undefined) {\n            var replacementData = JSON.stringify(replacements);\n            throw new Error(\"Error in translation for key '\".concat(id, \"'. No replacement found for key '\").concat(replacement, \"'. The following replacements were passed: '\").concat(replacementData, \"'\"));\n          } // This could be a string or a number, but JS doesn't mind which it gets\n          // and can handle that cast internally. So let it, to save us calling\n          // toString() on what's already a string in 90% of cases.\n\n\n          return replacements[replacement];\n        });\n      }\n\n      return text;\n    }\n  }, {\n    key: \"translationKeyExists\",\n    value: function translationKeyExists(path) {\n      return Boolean(get(this.translation, path));\n    }\n  }]);\n\n  return I18n;\n}();\n\nexport { I18n };","map":{"version":3,"sources":["/Users/ayubmohamed/emwb/node_modules/@shopify/polaris/build/esm/utilities/i18n/I18n.js"],"names":["get","merge","REPLACE_REGEX","I18n","translation","Array","isArray","slice","reverse","id","replacements","text","replace","match","replacement","substring","length","undefined","replacementData","JSON","stringify","Error","path","Boolean"],"mappings":";;;AAAA,SAASA,GAAT,QAAoB,WAApB;AACA,SAASC,KAAT,QAAsB,aAAtB;AAEA,IAAMC,aAAa,GAAG,YAAtB;;IACMC,I;AACJ;AACF;AACA;AACE,gBAAYC,WAAZ,EAAyB;AAAA;;AACvB,SAAKA,WAAL,GAAmB,EAAnB,CADuB,CAEvB;AACA;;AACA,SAAKA,WAAL,GAAmBC,KAAK,CAACC,OAAN,CAAcF,WAAd,IAA6BH,KAAK,MAAL,4BAASG,WAAW,CAACG,KAAZ,GAAoBC,OAApB,EAAT,EAA7B,GAAuEJ,WAA1F;AACD;;;;WAED,mBAAUK,EAAV,EAAcC,YAAd,EAA4B;AAC1B,UAAMC,IAAI,GAAGX,GAAG,CAAC,KAAKI,WAAN,EAAmBK,EAAnB,EAAuB,EAAvB,CAAhB;;AAEA,UAAI,CAACE,IAAL,EAAW;AACT,eAAO,EAAP;AACD;;AAED,UAAID,YAAJ,EAAkB;AAChB,eAAOC,IAAI,CAACC,OAAL,CAAaV,aAAb,EAA4B,UAAAW,KAAK,EAAI;AAC1C,cAAMC,WAAW,GAAGD,KAAK,CAACE,SAAN,CAAgB,CAAhB,EAAmBF,KAAK,CAACG,MAAN,GAAe,CAAlC,CAApB;;AAEA,cAAIN,YAAY,CAACI,WAAD,CAAZ,KAA8BG,SAAlC,EAA6C;AAC3C,gBAAMC,eAAe,GAAGC,IAAI,CAACC,SAAL,CAAeV,YAAf,CAAxB;AACA,kBAAM,IAAIW,KAAJ,yCAA2CZ,EAA3C,8CAAiFK,WAAjF,yDAA2II,eAA3I,OAAN;AACD,WANyC,CAMxC;AACF;AACA;;;AAGA,iBAAOR,YAAY,CAACI,WAAD,CAAnB;AACD,SAZM,CAAP;AAaD;;AAED,aAAOH,IAAP;AACD;;;WAED,8BAAqBW,IAArB,EAA2B;AACzB,aAAOC,OAAO,CAACvB,GAAG,CAAC,KAAKI,WAAN,EAAmBkB,IAAnB,CAAJ,CAAd;AACD;;;;;;AAIH,SAASnB,IAAT","sourcesContent":["import { get } from '../get.js';\nimport { merge } from '../merge.js';\n\nconst REPLACE_REGEX = /{([^}]*)}/g;\nclass I18n {\n  /**\n   * @param translation A locale object or array of locale objects that overrides default translations. If specifying an array then your desired language dictionary should come first, followed by your fallback language dictionaries\n   */\n  constructor(translation) {\n    this.translation = {};\n    // slice the array to make a shallow copy of it, so we don't accidentally\n    // modify the original translation array\n    this.translation = Array.isArray(translation) ? merge(...translation.slice().reverse()) : translation;\n  }\n\n  translate(id, replacements) {\n    const text = get(this.translation, id, '');\n\n    if (!text) {\n      return '';\n    }\n\n    if (replacements) {\n      return text.replace(REPLACE_REGEX, match => {\n        const replacement = match.substring(1, match.length - 1);\n\n        if (replacements[replacement] === undefined) {\n          const replacementData = JSON.stringify(replacements);\n          throw new Error(`Error in translation for key '${id}'. No replacement found for key '${replacement}'. The following replacements were passed: '${replacementData}'`);\n        } // This could be a string or a number, but JS doesn't mind which it gets\n        // and can handle that cast internally. So let it, to save us calling\n        // toString() on what's already a string in 90% of cases.\n\n\n        return replacements[replacement];\n      });\n    }\n\n    return text;\n  }\n\n  translationKeyExists(path) {\n    return Boolean(get(this.translation, path));\n  }\n\n}\n\nexport { I18n };\n"]},"metadata":{},"sourceType":"module"}