{"ast":null,"code":"import _objectSpread from \"/Users/ayubmohamed/emwb/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/ayubmohamed/emwb/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/ayubmohamed/emwb/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/ayubmohamed/emwb/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/ayubmohamed/emwb/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport React, { PureComponent } from 'react';\nimport { classNames } from '../../utilities/css.js';\nimport { getRectForNode, Rect } from '../../utilities/geometry.js';\nimport { dataPolarisTopBar, layer } from '../shared.js';\nimport { windowRect, calculateVerticalPosition, calculateHorizontalPosition, rectIsOutsideOfRect, intersectionWithViewport } from './utilities/math.js';\nimport styles from './PositionedOverlay.scss.js';\nimport { Scrollable } from '../Scrollable/Scrollable.js';\nimport { EventListener } from '../EventListener/EventListener.js';\nvar OBSERVER_CONFIG = {\n  childList: true,\n  subtree: true,\n  characterData: true\n};\n\nvar PositionedOverlay = /*#__PURE__*/function (_PureComponent) {\n  _inherits(PositionedOverlay, _PureComponent);\n\n  var _super = _createSuper(PositionedOverlay);\n\n  function PositionedOverlay(props) {\n    var _this;\n\n    _classCallCheck(this, PositionedOverlay);\n\n    _this = _super.call(this, props);\n    _this.state = {\n      measuring: true,\n      activatorRect: getRectForNode(_this.props.activator),\n      right: undefined,\n      left: undefined,\n      top: 0,\n      height: 0,\n      width: null,\n      positioning: 'below',\n      zIndex: null,\n      outsideScrollableContainer: false,\n      lockPosition: false\n    };\n    _this.overlay = null;\n    _this.scrollableContainer = null;\n    _this.observer = void 0;\n\n    _this.overlayDetails = function () {\n      var _this$state = _this.state,\n          measuring = _this$state.measuring,\n          left = _this$state.left,\n          right = _this$state.right,\n          positioning = _this$state.positioning,\n          height = _this$state.height,\n          activatorRect = _this$state.activatorRect;\n      return {\n        measuring: measuring,\n        left: left,\n        right: right,\n        desiredHeight: height,\n        positioning: positioning,\n        activatorRect: activatorRect\n      };\n    };\n\n    _this.setOverlay = function (node) {\n      _this.overlay = node;\n    };\n\n    _this.handleMeasurement = function () {\n      var _this$state2 = _this.state,\n          lockPosition = _this$state2.lockPosition,\n          top = _this$state2.top;\n\n      _this.observer.disconnect();\n\n      _this.setState(function (_ref) {\n        var left = _ref.left,\n            top = _ref.top,\n            right = _ref.right;\n        return {\n          left: left,\n          right: right,\n          top: top,\n          height: 0,\n          positioning: 'below',\n          measuring: true\n        };\n      }, function () {\n        if (_this.overlay == null || _this.scrollableContainer == null) {\n          return;\n        }\n\n        var _this$props = _this.props,\n            activator = _this$props.activator,\n            _this$props$preferred = _this$props.preferredPosition,\n            preferredPosition = _this$props$preferred === void 0 ? 'below' : _this$props$preferred,\n            _this$props$preferred2 = _this$props.preferredAlignment,\n            preferredAlignment = _this$props$preferred2 === void 0 ? 'center' : _this$props$preferred2,\n            onScrollOut = _this$props.onScrollOut,\n            fullWidth = _this$props.fullWidth,\n            fixed = _this$props.fixed,\n            _this$props$preferInp = _this$props.preferInputActivator,\n            preferInputActivator = _this$props$preferInp === void 0 ? true : _this$props$preferInp;\n        var preferredActivator = preferInputActivator ? activator.querySelector('input') || activator : activator;\n        var activatorRect = getRectForNode(preferredActivator);\n        var currentOverlayRect = getRectForNode(_this.overlay);\n        var scrollableElement = isDocument(_this.scrollableContainer) ? document.body : _this.scrollableContainer;\n        var scrollableContainerRect = getRectForNode(scrollableElement);\n        var overlayRect = fullWidth ? new Rect(_objectSpread(_objectSpread({}, currentOverlayRect), {}, {\n          width: activatorRect.width\n        })) : currentOverlayRect; // If `body` is 100% height, it still acts as though it were not constrained to that size. This adjusts for that.\n\n        if (scrollableElement === document.body) {\n          scrollableContainerRect.height = document.body.scrollHeight;\n        }\n\n        var topBarOffset = 0;\n        var topBarElement = scrollableElement.querySelector(\"\".concat(dataPolarisTopBar.selector));\n\n        if (topBarElement) {\n          topBarOffset = topBarElement.clientHeight;\n        }\n\n        var overlayMargins = _this.overlay.firstElementChild && _this.overlay.firstChild instanceof HTMLElement ? getMarginsForNode(_this.overlay.firstElementChild) : {\n          activator: 0,\n          container: 0,\n          horizontal: 0\n        };\n        var containerRect = windowRect();\n        var zIndexForLayer = getZIndexForLayerFromNode(activator);\n        var zIndex = zIndexForLayer == null ? zIndexForLayer : zIndexForLayer + 1;\n        var verticalPosition = calculateVerticalPosition(activatorRect, overlayRect, overlayMargins, scrollableContainerRect, containerRect, preferredPosition, fixed, topBarOffset);\n        var horizontalPosition = calculateHorizontalPosition(activatorRect, overlayRect, containerRect, overlayMargins, preferredAlignment);\n\n        _this.setState({\n          measuring: false,\n          activatorRect: getRectForNode(activator),\n          left: preferredAlignment !== 'right' ? horizontalPosition : undefined,\n          right: preferredAlignment === 'right' ? horizontalPosition : undefined,\n          top: lockPosition ? top : verticalPosition.top,\n          lockPosition: Boolean(fixed),\n          height: verticalPosition.height || 0,\n          width: fullWidth ? overlayRect.width : null,\n          positioning: verticalPosition.positioning,\n          outsideScrollableContainer: onScrollOut != null && rectIsOutsideOfRect(activatorRect, intersectionWithViewport(scrollableContainerRect)),\n          zIndex: zIndex\n        }, function () {\n          if (!_this.overlay) return;\n\n          _this.observer.observe(_this.overlay, OBSERVER_CONFIG);\n\n          _this.observer.observe(activator, OBSERVER_CONFIG);\n        });\n      });\n    };\n\n    _this.observer = new MutationObserver(_this.handleMeasurement);\n    return _this;\n  }\n\n  _createClass(PositionedOverlay, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.scrollableContainer = Scrollable.forNode(this.props.activator);\n\n      if (this.scrollableContainer && !this.props.fixed) {\n        this.scrollableContainer.addEventListener('scroll', this.handleMeasurement);\n      }\n\n      this.handleMeasurement();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.observer.disconnect();\n\n      if (this.scrollableContainer && !this.props.fixed) {\n        this.scrollableContainer.removeEventListener('scroll', this.handleMeasurement);\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      var _this$state3 = this.state,\n          outsideScrollableContainer = _this$state3.outsideScrollableContainer,\n          top = _this$state3.top;\n      var _this$props2 = this.props,\n          onScrollOut = _this$props2.onScrollOut,\n          active = _this$props2.active;\n\n      if (active && onScrollOut != null && top !== 0 && outsideScrollableContainer) {\n        onScrollOut();\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$state4 = this.state,\n          left = _this$state4.left,\n          right = _this$state4.right,\n          top = _this$state4.top,\n          zIndex = _this$state4.zIndex,\n          width = _this$state4.width;\n      var _this$props3 = this.props,\n          render = _this$props3.render,\n          fixed = _this$props3.fixed,\n          preventInteraction = _this$props3.preventInteraction,\n          propClassNames = _this$props3.classNames,\n          zIndexOverride = _this$props3.zIndexOverride;\n      var style = {\n        top: top == null || isNaN(top) ? undefined : top,\n        left: left == null || isNaN(left) ? undefined : left,\n        right: right == null || isNaN(right) ? undefined : right,\n        width: width == null || isNaN(width) ? undefined : width,\n        zIndex: zIndexOverride || zIndex || undefined\n      };\n      var className = classNames(styles.PositionedOverlay, fixed && styles.fixed, preventInteraction && styles.preventInteraction, propClassNames);\n      return /*#__PURE__*/React.createElement(\"div\", {\n        className: className,\n        style: style,\n        ref: this.setOverlay\n      }, /*#__PURE__*/React.createElement(EventListener, {\n        event: \"resize\",\n        handler: this.handleMeasurement\n      }), render(this.overlayDetails()));\n    }\n  }, {\n    key: \"forceUpdatePosition\",\n    value: function forceUpdatePosition() {\n      // Wait a single animation frame before re-measuring.\n      // Consumer's may also need to setup their own timers for\n      // triggering forceUpdatePosition() `children` use animation.\n      // Ideally, forceUpdatePosition() is fired at the end of a transition event.\n      requestAnimationFrame(this.handleMeasurement);\n    }\n  }]);\n\n  return PositionedOverlay;\n}(PureComponent);\n\nfunction getMarginsForNode(node) {\n  var nodeStyles = window.getComputedStyle(node);\n  return {\n    activator: parseFloat(nodeStyles.marginTop || '0'),\n    container: parseFloat(nodeStyles.marginBottom || '0'),\n    horizontal: parseFloat(nodeStyles.marginLeft || '0')\n  };\n}\n\nfunction getZIndexForLayerFromNode(node) {\n  var layerNode = node.closest(layer.selector) || document.body;\n  var zIndex = layerNode === document.body ? 'auto' : parseInt(window.getComputedStyle(layerNode).zIndex || '0', 10);\n  return zIndex === 'auto' || isNaN(zIndex) ? null : zIndex;\n}\n\nfunction isDocument(node) {\n  return node === document;\n}\n\nexport { PositionedOverlay };","map":{"version":3,"sources":["/Users/ayubmohamed/emwb/node_modules/@shopify/polaris/build/esm/components/PositionedOverlay/PositionedOverlay.js"],"names":["React","PureComponent","classNames","getRectForNode","Rect","dataPolarisTopBar","layer","windowRect","calculateVerticalPosition","calculateHorizontalPosition","rectIsOutsideOfRect","intersectionWithViewport","styles","Scrollable","EventListener","OBSERVER_CONFIG","childList","subtree","characterData","PositionedOverlay","props","state","measuring","activatorRect","activator","right","undefined","left","top","height","width","positioning","zIndex","outsideScrollableContainer","lockPosition","overlay","scrollableContainer","observer","overlayDetails","desiredHeight","setOverlay","node","handleMeasurement","disconnect","setState","preferredPosition","preferredAlignment","onScrollOut","fullWidth","fixed","preferInputActivator","preferredActivator","querySelector","currentOverlayRect","scrollableElement","isDocument","document","body","scrollableContainerRect","overlayRect","scrollHeight","topBarOffset","topBarElement","selector","clientHeight","overlayMargins","firstElementChild","firstChild","HTMLElement","getMarginsForNode","container","horizontal","containerRect","zIndexForLayer","getZIndexForLayerFromNode","verticalPosition","horizontalPosition","Boolean","observe","MutationObserver","forNode","addEventListener","removeEventListener","active","render","preventInteraction","propClassNames","zIndexOverride","style","isNaN","className","createElement","ref","event","handler","requestAnimationFrame","nodeStyles","window","getComputedStyle","parseFloat","marginTop","marginBottom","marginLeft","layerNode","closest","parseInt"],"mappings":"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","sourcesContent":["import React, { PureComponent } from 'react';\nimport { classNames } from '../../utilities/css.js';\nimport { getRectForNode, Rect } from '../../utilities/geometry.js';\nimport { dataPolarisTopBar, layer } from '../shared.js';\nimport { windowRect, calculateVerticalPosition, calculateHorizontalPosition, rectIsOutsideOfRect, intersectionWithViewport } from './utilities/math.js';\nimport styles from './PositionedOverlay.scss.js';\nimport { Scrollable } from '../Scrollable/Scrollable.js';\nimport { EventListener } from '../EventListener/EventListener.js';\n\nconst OBSERVER_CONFIG = {\n  childList: true,\n  subtree: true,\n  characterData: true\n};\nclass PositionedOverlay extends PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = {\n      measuring: true,\n      activatorRect: getRectForNode(this.props.activator),\n      right: undefined,\n      left: undefined,\n      top: 0,\n      height: 0,\n      width: null,\n      positioning: 'below',\n      zIndex: null,\n      outsideScrollableContainer: false,\n      lockPosition: false\n    };\n    this.overlay = null;\n    this.scrollableContainer = null;\n    this.observer = void 0;\n\n    this.overlayDetails = () => {\n      const {\n        measuring,\n        left,\n        right,\n        positioning,\n        height,\n        activatorRect\n      } = this.state;\n      return {\n        measuring,\n        left,\n        right,\n        desiredHeight: height,\n        positioning,\n        activatorRect\n      };\n    };\n\n    this.setOverlay = node => {\n      this.overlay = node;\n    };\n\n    this.handleMeasurement = () => {\n      const {\n        lockPosition,\n        top\n      } = this.state;\n      this.observer.disconnect();\n      this.setState(({\n        left,\n        top,\n        right\n      }) => ({\n        left,\n        right,\n        top,\n        height: 0,\n        positioning: 'below',\n        measuring: true\n      }), () => {\n        if (this.overlay == null || this.scrollableContainer == null) {\n          return;\n        }\n\n        const {\n          activator,\n          preferredPosition = 'below',\n          preferredAlignment = 'center',\n          onScrollOut,\n          fullWidth,\n          fixed,\n          preferInputActivator = true\n        } = this.props;\n        const preferredActivator = preferInputActivator ? activator.querySelector('input') || activator : activator;\n        const activatorRect = getRectForNode(preferredActivator);\n        const currentOverlayRect = getRectForNode(this.overlay);\n        const scrollableElement = isDocument(this.scrollableContainer) ? document.body : this.scrollableContainer;\n        const scrollableContainerRect = getRectForNode(scrollableElement);\n        const overlayRect = fullWidth ? new Rect({ ...currentOverlayRect,\n          width: activatorRect.width\n        }) : currentOverlayRect; // If `body` is 100% height, it still acts as though it were not constrained to that size. This adjusts for that.\n\n        if (scrollableElement === document.body) {\n          scrollableContainerRect.height = document.body.scrollHeight;\n        }\n\n        let topBarOffset = 0;\n        const topBarElement = scrollableElement.querySelector(`${dataPolarisTopBar.selector}`);\n\n        if (topBarElement) {\n          topBarOffset = topBarElement.clientHeight;\n        }\n\n        const overlayMargins = this.overlay.firstElementChild && this.overlay.firstChild instanceof HTMLElement ? getMarginsForNode(this.overlay.firstElementChild) : {\n          activator: 0,\n          container: 0,\n          horizontal: 0\n        };\n        const containerRect = windowRect();\n        const zIndexForLayer = getZIndexForLayerFromNode(activator);\n        const zIndex = zIndexForLayer == null ? zIndexForLayer : zIndexForLayer + 1;\n        const verticalPosition = calculateVerticalPosition(activatorRect, overlayRect, overlayMargins, scrollableContainerRect, containerRect, preferredPosition, fixed, topBarOffset);\n        const horizontalPosition = calculateHorizontalPosition(activatorRect, overlayRect, containerRect, overlayMargins, preferredAlignment);\n        this.setState({\n          measuring: false,\n          activatorRect: getRectForNode(activator),\n          left: preferredAlignment !== 'right' ? horizontalPosition : undefined,\n          right: preferredAlignment === 'right' ? horizontalPosition : undefined,\n          top: lockPosition ? top : verticalPosition.top,\n          lockPosition: Boolean(fixed),\n          height: verticalPosition.height || 0,\n          width: fullWidth ? overlayRect.width : null,\n          positioning: verticalPosition.positioning,\n          outsideScrollableContainer: onScrollOut != null && rectIsOutsideOfRect(activatorRect, intersectionWithViewport(scrollableContainerRect)),\n          zIndex\n        }, () => {\n          if (!this.overlay) return;\n          this.observer.observe(this.overlay, OBSERVER_CONFIG);\n          this.observer.observe(activator, OBSERVER_CONFIG);\n        });\n      });\n    };\n\n    this.observer = new MutationObserver(this.handleMeasurement);\n  }\n\n  componentDidMount() {\n    this.scrollableContainer = Scrollable.forNode(this.props.activator);\n\n    if (this.scrollableContainer && !this.props.fixed) {\n      this.scrollableContainer.addEventListener('scroll', this.handleMeasurement);\n    }\n\n    this.handleMeasurement();\n  }\n\n  componentWillUnmount() {\n    this.observer.disconnect();\n\n    if (this.scrollableContainer && !this.props.fixed) {\n      this.scrollableContainer.removeEventListener('scroll', this.handleMeasurement);\n    }\n  }\n\n  componentDidUpdate() {\n    const {\n      outsideScrollableContainer,\n      top\n    } = this.state;\n    const {\n      onScrollOut,\n      active\n    } = this.props;\n\n    if (active && onScrollOut != null && top !== 0 && outsideScrollableContainer) {\n      onScrollOut();\n    }\n  }\n\n  render() {\n    const {\n      left,\n      right,\n      top,\n      zIndex,\n      width\n    } = this.state;\n    const {\n      render,\n      fixed,\n      preventInteraction,\n      classNames: propClassNames,\n      zIndexOverride\n    } = this.props;\n    const style = {\n      top: top == null || isNaN(top) ? undefined : top,\n      left: left == null || isNaN(left) ? undefined : left,\n      right: right == null || isNaN(right) ? undefined : right,\n      width: width == null || isNaN(width) ? undefined : width,\n      zIndex: zIndexOverride || zIndex || undefined\n    };\n    const className = classNames(styles.PositionedOverlay, fixed && styles.fixed, preventInteraction && styles.preventInteraction, propClassNames);\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: className,\n      style: style,\n      ref: this.setOverlay\n    }, /*#__PURE__*/React.createElement(EventListener, {\n      event: \"resize\",\n      handler: this.handleMeasurement\n    }), render(this.overlayDetails()));\n  }\n\n  forceUpdatePosition() {\n    // Wait a single animation frame before re-measuring.\n    // Consumer's may also need to setup their own timers for\n    // triggering forceUpdatePosition() `children` use animation.\n    // Ideally, forceUpdatePosition() is fired at the end of a transition event.\n    requestAnimationFrame(this.handleMeasurement);\n  }\n\n}\n\nfunction getMarginsForNode(node) {\n  const nodeStyles = window.getComputedStyle(node);\n  return {\n    activator: parseFloat(nodeStyles.marginTop || '0'),\n    container: parseFloat(nodeStyles.marginBottom || '0'),\n    horizontal: parseFloat(nodeStyles.marginLeft || '0')\n  };\n}\n\nfunction getZIndexForLayerFromNode(node) {\n  const layerNode = node.closest(layer.selector) || document.body;\n  const zIndex = layerNode === document.body ? 'auto' : parseInt(window.getComputedStyle(layerNode).zIndex || '0', 10);\n  return zIndex === 'auto' || isNaN(zIndex) ? null : zIndex;\n}\n\nfunction isDocument(node) {\n  return node === document;\n}\n\nexport { PositionedOverlay };\n"]},"metadata":{},"sourceType":"module"}